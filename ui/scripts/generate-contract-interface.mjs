import fs from 'node:fs';
import path from 'node:path';

const repoRoot = path.resolve(process.cwd(), '..');
const abiPath = path.join(process.cwd(), 'src', 'abis', 'agiJobManager.ts');
const source = fs.readFileSync(abiPath, 'utf8');

const start = source.indexOf('[');
const end = source.lastIndexOf('] as const');
if (start === -1 || end === -1) throw new Error('Unable to parse agiJobManagerAbi literal');
const abiJson = source.slice(start, end + 1);
const abi = JSON.parse(abiJson);

const listByType = (type) => abi.filter((item) => item.type === type).map((item) => item.name).sort();

const functions = listByType('function');
const events = listByType('event');
const errors = listByType('error');

const section = (title, items) => `## ${title}\n\n${items.map((item) => `- \`${item}\``).join('\n')}\n`;

const markdown = `# Contract Interface Used by UI\n\nGenerated by \`ui/scripts/generate-contract-interface.mjs\` from \`ui/src/abis/agiJobManager.ts\`.\n\n- Generated at: ${new Date().toISOString()}\n- ABI entries parsed: ${abi.length}\n\n${section('Functions used', functions)}\n${section('Events used', events)}\n${section('Custom errors used', errors)}\n## UI compatibility contract\n\nThe UI assumes the deployed contract exposes these getters and state transitions:\n\n1. Read-only rendering can rely on \`owner\`, pause flags, \`nextJobId\`, and per-job core/validation/URI getters.\n2. Write actions remain simulation-first and rely on custom error names for operator guidance.\n3. Event timeline is best-effort and tolerant of missing logs.\n4. UI does not require non-ABI storage introspection, indexers, or backend custody.\n`;

const output = path.join(repoRoot, 'docs', 'ui', 'CONTRACT_INTERFACE.md');
fs.writeFileSync(output, markdown);
console.log(`Wrote ${path.relative(repoRoot, output)}`);
