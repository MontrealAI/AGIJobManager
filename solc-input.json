{"language":"Solidity","sources":{"contracts/AGIJobManager.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/*\n\n[ R E G U L A T O R Y  C O M P L I A N C E  &  L E G A L  D I S C L O S U R E S ]\n\nPublished by: ALPHA.AGI.ETH\n\nApproval Authority: ALPHA.AGI.ETH\n\nOffice of Primary Responsibility: ALPHA.AGI.ETH\n\nInitial Terms & Conditions\n\nThe Emergence of an AGI-Powered Alpha Agent.\n\nTicker ($): AGIALPHA\n\nRooted in the publicly disclosed 2017 \"Multi-Agent AI DAO\" prior art, the AGI ALPHA AGENT utilizes $AGIALPHA tokens purely as utility tokens—no equity, no profit-sharing—to grant users prepaid access to the AGI ALPHA AGENT’s capabilities. By structuring $AGIALPHA as an advance payment mechanism for leveraging ALPHA.AGENT.AGI.Eth’s AI-driven services, holders likely avoid securities classification complexities. By purchasing these tokens, you gain usage credits for future AI services from the AGI ALPHA AGENT. Instead of representing ownership or investment rights, these tokens simply secure the right to interact with and benefit from the AGI ALPHA AGENT’s intelligence and outputs. This model delivers a straightforward, compliance-friendly approach to accessing cutting-edge AI functionalities, ensuring a seamless, equity-free experience for all participants.\n\n1. Token Usage: $AGIALPHA tokens are strictly utility tokens—no equity, no profit-sharing—intended for the purchase of products/services by the AGI ALPHA AGENT (ALPHA.AGENT.AGI.Eth). They are not intended for investment or speculative purposes.\n\n2. Non-Refundable: Purchases of $AGIALPHA tokens are final and non-refundable.\n\n3. No Guarantee of Value: The issuer does not guarantee any specific value of the $AGIALPHA token in relation to fiat currencies or other cryptocurrencies.\n\n4. Regulatory Compliance: It is the user’s responsibility to ensure that the purchase and use of $AGIALPHA tokens comply with all applicable laws and regulations.\n\n5. User Responsibility: Users are responsible for complying with the laws in their own jurisdiction regarding the purchase and use of $AGIALPHA tokens.\n\nOVERRIDING AUTHORITY: AGI.Eth\n\n$AGIALPHA is experimental and part of an ambitious research agenda. Any expectation of profit is unjustified.\n\nMaterials provided (including $AGIALPHA) are without warranty. By using $AGIALPHA, you agree to the $AGIALPHA Terms and Conditions.\n\nChanges to Terms: The issuer may revise these terms at any time, subject to regulatory compliance. Current Terms & Conditions: https://agialphaagent.com/.\n\nTHIS IS PART OF AN ASPIRATIONAL RESEARCH PROGRAM WITH AN AMBITIOUS RESEARCH AGENDA. ANY EXPECTATION OF PROFIT OR RETURN IS UNJUSTIFIED. POSSESSION OF $AGIALPHA DOES NOT SIGNIFY OR ESTABLISH ANY ENTITLEMENT OR INTEREST, SHARE OR EQUITY, BOND OR ANALOGOUS ENTITLEMENT, OR ANY RIGHT TO OBTAIN ANY FUTURE INCOME. MATERIALS PROVIDED IN THIS SYSTEM ARE WITHOUT WARRANTY OF ANY KIND AND DO NOT CONSTITUTE ENDORSEMENT AND CAN BE MODIFIED AT ANY TIME. BY USING THE PRESENT SYSTEM, YOU AGREE TO THE $AGIALPHA TERMS AND CONDITIONS. ANY USE OF THIS SYSTEM, OR ANY OF THE INFORMATION CONTAINED HEREIN, FOR OTHER THAN THE PURPOSE FOR WHICH IT WAS DEVELOPED, IS EXPRESSLY PROHIBITED, EXCEPT AS AGI.ETH MAY OTHERWISE AGREE TO IN WRITING OFFICIALLY.\n\nOVERRIDING AUTHORITY: AGI.ETH\n\n*/\n\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\ninterface ENS {\n    function resolver(bytes32 node) external view returns (address);\n}\n\ninterface Resolver {\n    function addr(bytes32 node) external view returns (address payable);\n}\n\ninterface NameWrapper {\n    function ownerOf(uint256 id) external view returns (address);\n}\n\ncontract AGIJobManager is Ownable, ReentrancyGuard, Pausable, ERC721 {\n    using MerkleProof for bytes32[];\n\n    // -----------------------\n    // Custom errors (smaller bytecode than revert strings)\n    // -----------------------\n    error NotModerator();\n    error NotAuthorized();\n    error Blacklisted();\n    error InvalidParameters();\n    error InvalidState();\n    error JobNotFound();\n    error TransferFailed();\n    error ValidatorLimitReached();\n    error InvalidValidatorThresholds();\n    error ValidatorSetTooLarge();\n    error IneligibleAgentPayout();\n    error InvalidAgentPayoutSnapshot();\n    error InsufficientWithdrawableBalance();\n    error InsolventEscrowBalance();\n\n    bool public configLocked;\n\n    event ConfigurationLocked(address indexed by);\n\n    /// @notice Canonical job lifecycle status enum (numeric ordering is stable; do not reorder).\n    /// @dev 0 = Deleted (employer == address(0) or removed)\n    /// @dev 1 = Open (exists, employer set, no assigned agent)\n    /// @dev 2 = InProgress (assigned agent, not completed, not disputed, no completion request)\n    /// @dev 3 = CompletionRequested (agent requested completion)\n    /// @dev 4 = Disputed (disputed flag on)\n    /// @dev 5 = Completed (completed flag on)\n    /// @dev 6 = Expired (computed timeout; informational if expireJob not called)\n    enum JobStatus {\n        Deleted,\n        Open,\n        InProgress,\n        CompletionRequested,\n        Disputed,\n        Completed,\n        Expired\n    }\n\n    /// @notice Canonical dispute resolution codes (numeric ordering is stable; do not reorder).\n    /// @dev 0 = NO_ACTION (log only; dispute remains active)\n    /// @dev 1 = AGENT_WIN (settle in favor of agent)\n    /// @dev 2 = EMPLOYER_WIN (settle in favor of employer)\n    enum DisputeResolutionCode {\n        NO_ACTION,\n        AGENT_WIN,\n        EMPLOYER_WIN\n    }\n\n    // Pre-hashed resolution strings (smaller + cheaper than hashing literals each call)\n    bytes32 private constant RES_AGENT_WIN = 0x6594a8dd3f558fd2dd11fa44c7925f5b9e19868e6d0b4b97d2132fe5e25b5071;\n    bytes32 private constant RES_EMPLOYER_WIN = 0xee31e9f396a85b8517c6d07b02f904858ad9f3456521bedcff02cc14e75ca8ce;\n\n    IERC20 public agiToken;\n    string private baseIpfsUrl;\n    // Conservative hard cap to bound settlement loops on mainnet.\n    uint256 public constant MAX_VALIDATORS_PER_JOB = 50;\n    uint256 public requiredValidatorApprovals = 3;\n    uint256 public requiredValidatorDisapprovals = 3;\n    uint256 public premiumReputationThreshold = 10000;\n    uint256 public validationRewardPercentage = 8;\n    uint256 public maxJobPayout = 4888e18;\n    uint256 public jobDurationLimit = 10000000;\n    uint256 public completionReviewPeriod = 7 days;\n    uint256 public disputeReviewPeriod = 14 days;\n    uint256 internal constant MAX_REVIEW_PERIOD = 365 days;\n    uint256 public additionalAgentPayoutPercentage = 50;\n    /// @notice Total AGI reserved for unsettled job escrows.\n    /// @dev Tracks job payout escrows only.\n    uint256 public lockedEscrow;\n\n    string public termsAndConditionsIpfsHash;\n    string public contactEmail;\n    string public additionalText1;\n    string public additionalText2;\n    string public additionalText3;\n\n    bytes32 public clubRootNode;\n    bytes32 public clubRootNodeAlpha;\n    bytes32 public agentRootNode;\n    bytes32 public agentRootNodeAlpha;\n    bytes32 public validatorMerkleRoot;\n    bytes32 public agentMerkleRoot;\n    ENS public ens;\n    NameWrapper public nameWrapper;\n\n    struct Job {\n        uint256 id;\n        address employer;\n        string jobSpecURI;\n        string jobCompletionURI;\n        string ipfsHash;\n        uint256 payout;\n        uint256 duration;\n        address assignedAgent;\n        uint256 assignedAt;\n        bool completed;\n        bool completionRequested;\n        uint256 validatorApprovals;\n        uint256 validatorDisapprovals;\n        bool disputed;\n        string details;\n        mapping(address => bool) approvals;\n        mapping(address => bool) disapprovals;\n        address[] validators;\n        uint256 completionRequestedAt;\n        uint256 disputedAt;\n        bool expired;\n        uint8 agentPayoutPct;\n        bool escrowReleased;\n    }\n\n    struct AGIType {\n        address nftAddress;\n        uint256 payoutPercentage;\n    }\n\n    struct Listing {\n        uint256 tokenId;\n        address seller;\n        uint256 price;\n        bool isActive;\n    }\n\n    uint256 public nextJobId;\n    uint256 public nextTokenId;\n    mapping(uint256 => Job) public jobs;\n    mapping(address => uint256) public reputation;\n    mapping(address => bool) public moderators;\n    mapping(address => bool) public additionalValidators;\n    mapping(address => bool) public additionalAgents;\n    mapping(address => uint256[]) public validatorApprovedJobs;\n    mapping(uint256 => Listing) public listings;\n    mapping(address => bool) public blacklistedAgents;\n    mapping(address => bool) public blacklistedValidators;\n    AGIType[] public agiTypes;\n    mapping(uint256 => string) private _tokenURIs;\n\n    event JobCreated(uint256 jobId, string jobSpecURI, uint256 payout, uint256 duration, string details);\n    event JobApplied(uint256 jobId, address agent);\n    event JobCompletionRequested(uint256 jobId, address agent, string jobCompletionURI);\n    event JobValidated(uint256 jobId, address validator);\n    event JobDisapproved(uint256 jobId, address validator);\n    event JobCompleted(uint256 jobId, address agent, uint256 reputationPoints);\n    event ReputationUpdated(address user, uint256 newReputation);\n    event JobCancelled(uint256 jobId);\n    event DisputeResolved(uint256 jobId, address resolver, string resolution);\n    event DisputeResolvedWithCode(uint256 jobId, address resolver, uint8 resolutionCode, string reason);\n    event JobDisputed(uint256 jobId, address disputant);\n    event JobExpired(uint256 jobId, address employer, address agent, uint256 payout);\n    event JobFinalized(uint256 jobId, address agent, address employer, bool agentPaid, uint256 payout);\n    event DisputeTimeoutResolved(uint256 jobId, address resolver, bool employerWins);\n    event RootNodeUpdated(bytes32 indexed newRootNode);\n    event MerkleRootUpdated(bytes32 indexed newMerkleRoot);\n    event OwnershipVerified(address claimant, string subdomain);\n    event RecoveryInitiated(string reason);\n    event AGITypeUpdated(address indexed nftAddress, uint256 payoutPercentage);\n    event NFTIssued(uint256 indexed tokenId, address indexed employer, string tokenURI);\n    event NFTListed(uint256 indexed tokenId, address indexed seller, uint256 price);\n    event NFTPurchased(uint256 indexed tokenId, address indexed buyer, uint256 price);\n    event NFTDelisted(uint256 indexed tokenId);\n    event RewardPoolContribution(address indexed contributor, uint256 amount);\n    event CompletionReviewPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\n    event DisputeReviewPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\n    event AdditionalAgentPayoutPercentageUpdated(uint256 newPercentage);\n    event AGIWithdrawn(address indexed to, uint256 amount, uint256 remainingWithdrawable);\n\n    modifier whenConfigurable() {\n        if (configLocked) revert InvalidState();\n        _;\n    }\n\n    constructor(\n        address _agiTokenAddress,\n        string memory _baseIpfsUrl,\n        address _ensAddress,\n        address _nameWrapperAddress,\n        bytes32 _clubRootNode,\n        bytes32 _agentRootNode,\n        bytes32 _clubRootNodeAlpha,\n        bytes32 _agentRootNodeAlpha,\n        bytes32 _validatorMerkleRoot,\n        bytes32 _agentMerkleRoot\n    ) ERC721(\"AGIJobs\", \"Job\") {\n        agiToken = IERC20(_agiTokenAddress);\n        baseIpfsUrl = _baseIpfsUrl;\n        ens = ENS(_ensAddress);\n        nameWrapper = NameWrapper(_nameWrapperAddress);\n        clubRootNode = _clubRootNode;\n        agentRootNode = _agentRootNode;\n        clubRootNodeAlpha = _clubRootNodeAlpha;\n        agentRootNodeAlpha = _agentRootNodeAlpha;\n        validatorMerkleRoot = _validatorMerkleRoot;\n        agentMerkleRoot = _agentMerkleRoot;\n\n        _validateValidatorThresholds(requiredValidatorApprovals, requiredValidatorDisapprovals);\n    }\n\n    modifier onlyModerator() {\n        if (!moderators[msg.sender]) revert NotModerator();\n        _;\n    }\n\n    // -----------------------\n    // Internal helpers\n    // -----------------------\n    function _job(uint256 jobId) internal view returns (Job storage job) {\n        job = jobs[jobId];\n        if (job.employer == address(0)) revert JobNotFound();\n    }\n\n    function _t(address to, uint256 amount) internal {\n        _safeERC20Transfer(agiToken, to, amount);\n    }\n\n    function _tFrom(address from, address to, uint256 amount) internal {\n        _safeERC20TransferFrom(agiToken, from, to, amount);\n    }\n\n    function _safeERC20Transfer(IERC20 token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\n    }\n\n    function _safeERC20TransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\n    }\n\n    function _safeERC20TransferFromExact(IERC20 token, address from, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        uint256 balanceBefore = token.balanceOf(to);\n        _safeERC20TransferFrom(token, from, to, amount);\n        uint256 balanceAfter = token.balanceOf(to);\n        if (balanceAfter < balanceBefore || balanceAfter - balanceBefore != amount) revert TransferFailed();\n    }\n\n    function _releaseEscrow(Job storage job) internal {\n        if (job.escrowReleased) return;\n        job.escrowReleased = true;\n        unchecked {\n            lockedEscrow -= job.payout;\n        }\n    }\n\n    function _validateValidatorThresholds(uint256 approvals, uint256 disapprovals) internal pure {\n        if (\n            approvals > MAX_VALIDATORS_PER_JOB ||\n            disapprovals > MAX_VALIDATORS_PER_JOB ||\n            approvals + disapprovals > MAX_VALIDATORS_PER_JOB\n        ) {\n            revert InvalidValidatorThresholds();\n        }\n    }\n\n    function _enforceValidatorCapacity(uint256 currentCount) internal pure {\n        if (currentCount >= MAX_VALIDATORS_PER_JOB) revert ValidatorLimitReached();\n    }\n\n    function _maxAGITypePayoutPercentage() internal view returns (uint256) {\n        uint256 maxPercentage = 0;\n        for (uint256 i = 0; i < agiTypes.length; ) {\n            uint256 pct = agiTypes[i].payoutPercentage;\n            if (pct > maxPercentage) {\n                maxPercentage = pct;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return maxPercentage;\n    }\n\n    function _callOptionalReturn(IERC20 token, bytes memory data) internal {\n        (bool success, bytes memory returndata) = address(token).call(data);\n        if (!success) revert TransferFailed();\n        if (returndata.length == 0) return;\n        if (returndata.length == 32) {\n            if (!abi.decode(returndata, (bool))) revert TransferFailed();\n            return;\n        }\n        revert TransferFailed();\n    }\n\n    function pause() external onlyOwner { _pause(); }\n    function unpause() external onlyOwner { _unpause(); }\n    function lockConfiguration() external onlyOwner {\n        if (configLocked) revert InvalidState();\n        configLocked = true;\n        emit ConfigurationLocked(msg.sender);\n    }\n\n    function createJob(string memory _jobSpecURI, uint256 _payout, uint256 _duration, string memory _details) external whenNotPaused nonReentrant {\n        if (!(_payout > 0 && _duration > 0 && _payout <= maxJobPayout && _duration <= jobDurationLimit)) revert InvalidParameters();\n        _requireValidUri(_jobSpecURI);\n        uint256 jobId = nextJobId;\n        unchecked {\n            ++nextJobId;\n        }\n        Job storage job = jobs[jobId];\n        job.id = jobId;\n        job.employer = msg.sender;\n        job.jobSpecURI = _jobSpecURI;\n        job.ipfsHash = _jobSpecURI;\n        job.payout = _payout;\n        job.duration = _duration;\n        job.details = _details;\n        _safeERC20TransferFromExact(agiToken, msg.sender, address(this), _payout);\n        unchecked {\n            lockedEscrow += _payout;\n        }\n        emit JobCreated(jobId, _jobSpecURI, _payout, _duration, _details);\n    }\n\n    function applyForJob(uint256 _jobId, string memory subdomain, bytes32[] calldata proof) external whenNotPaused nonReentrant {\n        Job storage job = _job(_jobId);\n        if (job.assignedAgent != address(0)) revert InvalidState();\n        if (blacklistedAgents[msg.sender]) revert Blacklisted();\n        if (!(additionalAgents[msg.sender] || _verifyOwnershipAgent(msg.sender, subdomain, proof))) revert NotAuthorized();\n        uint256 snapshotPct = getHighestPayoutPercentage(msg.sender);\n        if (snapshotPct == 0) revert IneligibleAgentPayout();\n        job.agentPayoutPct = uint8(snapshotPct);\n        job.assignedAgent = msg.sender;\n        job.assignedAt = block.timestamp;\n        emit JobApplied(_jobId, msg.sender);\n    }\n\n    function requestJobCompletion(uint256 _jobId, string calldata _jobCompletionURI) external {\n        Job storage job = _job(_jobId);\n        if (bytes(_jobCompletionURI).length == 0) revert InvalidParameters();\n        require(!paused() || job.disputed, \"Pausable: paused\");\n        if (msg.sender != job.assignedAgent) revert NotAuthorized();\n        if (job.completed || job.expired) revert InvalidState();\n        if (!job.disputed && block.timestamp > job.assignedAt + job.duration) revert InvalidState();\n        if (job.completionRequested) revert InvalidState();\n        _requireValidUri(_jobCompletionURI);\n        job.jobCompletionURI = _jobCompletionURI;\n        job.completionRequested = true;\n        job.completionRequestedAt = block.timestamp;\n        emit JobCompletionRequested(_jobId, msg.sender, _jobCompletionURI);\n    }\n\n    function validateJob(uint256 _jobId, string memory subdomain, bytes32[] calldata proof) external whenNotPaused nonReentrant {\n        Job storage job = _job(_jobId);\n        if (job.disputed) revert InvalidState();\n        if (job.assignedAgent == address(0)) revert InvalidState();\n        if (job.completed) revert InvalidState();\n        if (job.expired) revert InvalidState();\n        if (blacklistedValidators[msg.sender]) revert Blacklisted();\n        if (!(additionalValidators[msg.sender] || _verifyOwnershipValidator(msg.sender, subdomain, proof))) revert NotAuthorized();\n        if (!job.completionRequested) revert InvalidState();\n        if (job.approvals[msg.sender]) revert InvalidState();\n        if (job.disapprovals[msg.sender]) revert InvalidState();\n\n        _enforceValidatorCapacity(job.validators.length);\n        job.validatorApprovals++;\n        job.approvals[msg.sender] = true;\n        job.validators.push(msg.sender);\n        validatorApprovedJobs[msg.sender].push(_jobId);\n        emit JobValidated(_jobId, msg.sender);\n        if (job.validatorApprovals >= requiredValidatorApprovals) _completeJob(_jobId);\n    }\n\n    function disapproveJob(uint256 _jobId, string memory subdomain, bytes32[] calldata proof) external whenNotPaused nonReentrant {\n        Job storage job = _job(_jobId);\n        if (job.disputed) revert InvalidState();\n        if (job.assignedAgent == address(0)) revert InvalidState();\n        if (job.completed) revert InvalidState();\n        if (job.expired) revert InvalidState();\n        if (blacklistedValidators[msg.sender]) revert Blacklisted();\n        if (!(additionalValidators[msg.sender] || _verifyOwnershipValidator(msg.sender, subdomain, proof))) revert NotAuthorized();\n        if (!job.completionRequested) revert InvalidState();\n        if (job.disapprovals[msg.sender]) revert InvalidState();\n        if (job.approvals[msg.sender]) revert InvalidState();\n\n        _enforceValidatorCapacity(job.validators.length);\n        job.validatorDisapprovals++;\n        job.disapprovals[msg.sender] = true;\n        job.validators.push(msg.sender);\n        validatorApprovedJobs[msg.sender].push(_jobId);\n        emit JobDisapproved(_jobId, msg.sender);\n        if (job.validatorDisapprovals >= requiredValidatorDisapprovals) {\n            job.disputed = true;\n            if (job.disputedAt == 0) {\n                job.disputedAt = block.timestamp;\n            }\n            emit JobDisputed(_jobId, msg.sender);\n        }\n    }\n\n    function disputeJob(uint256 _jobId) external whenNotPaused nonReentrant {\n        Job storage job = _job(_jobId);\n        if (job.disputed || job.completed || job.expired) revert InvalidState();\n        if (msg.sender != job.assignedAgent && msg.sender != job.employer) revert NotAuthorized();\n        if (!job.completionRequested) revert InvalidState();\n        job.disputed = true;\n        if (job.disputedAt == 0) {\n            job.disputedAt = block.timestamp;\n        }\n        emit JobDisputed(_jobId, msg.sender);\n    }\n\n    /// @notice Deprecated: use resolveDisputeWithCode for typed settlement.\n    /// @dev Non-canonical strings map to NO_ACTION (dispute remains active).\n    function resolveDispute(uint256 _jobId, string calldata resolution) external onlyModerator nonReentrant {\n        uint8 resolutionCode = uint8(DisputeResolutionCode.NO_ACTION);\n        bytes32 r = keccak256(bytes(resolution));\n        if (r == RES_AGENT_WIN) {\n            resolutionCode = uint8(DisputeResolutionCode.AGENT_WIN);\n        } else if (r == RES_EMPLOYER_WIN) {\n            resolutionCode = uint8(DisputeResolutionCode.EMPLOYER_WIN);\n        }\n        _resolveDispute(_jobId, resolutionCode, resolution);\n    }\n\n    /// @notice Resolve a dispute with a typed action code and freeform reason.\n    function resolveDisputeWithCode(\n        uint256 _jobId,\n        uint8 resolutionCode,\n        string calldata reason\n    ) external onlyModerator nonReentrant {\n        _resolveDispute(_jobId, resolutionCode, reason);\n    }\n\n    function _resolveDispute(uint256 _jobId, uint8 resolutionCode, string memory reason) internal {\n        Job storage job = _job(_jobId);\n        if (!job.disputed || job.expired) revert InvalidState();\n\n        if (resolutionCode == uint8(DisputeResolutionCode.NO_ACTION)) {\n            emit DisputeResolvedWithCode(_jobId, msg.sender, resolutionCode, reason);\n            return;\n        }\n\n        job.disputed = false;\n        job.disputedAt = 0;\n\n        if (resolutionCode == uint8(DisputeResolutionCode.AGENT_WIN)) {\n            _completeJob(_jobId);\n        } else if (resolutionCode == uint8(DisputeResolutionCode.EMPLOYER_WIN)) {\n            _refundEmployer(job);\n        } else {\n            revert InvalidParameters();\n        }\n\n        string memory legacyResolution = resolutionCode == uint8(DisputeResolutionCode.AGENT_WIN)\n            ? \"agent win\"\n            : \"employer win\";\n        emit DisputeResolved(_jobId, msg.sender, legacyResolution);\n        emit DisputeResolvedWithCode(_jobId, msg.sender, resolutionCode, reason);\n    }\n\n    function resolveStaleDispute(uint256 _jobId, bool employerWins) external onlyOwner whenPaused nonReentrant {\n        Job storage job = _job(_jobId);\n        if (!job.disputed || job.expired) revert InvalidState();\n        if (job.disputedAt == 0) revert InvalidState();\n        if (block.timestamp <= job.disputedAt + disputeReviewPeriod) revert InvalidState();\n\n        emit RecoveryInitiated(\"DISPUTE_TIMEOUT\");\n        if (employerWins) {\n            _refundEmployer(job);\n        } else {\n            job.disputed = false;\n            job.disputedAt = 0;\n            _completeJob(_jobId);\n        }\n        emit DisputeTimeoutResolved(_jobId, msg.sender, employerWins);\n    }\n\n    function blacklistAgent(address _agent, bool _status) external onlyOwner { blacklistedAgents[_agent] = _status; }\n    function blacklistValidator(address _validator, bool _status) external onlyOwner { blacklistedValidators[_validator] = _status; }\n\n    function delistJob(uint256 _jobId) external onlyOwner {\n        Job storage job = _job(_jobId);\n        if (job.completed || job.assignedAgent != address(0)) revert InvalidState();\n        _releaseEscrow(job);\n        _t(job.employer, job.payout);\n        delete jobs[_jobId];\n        emit JobCancelled(_jobId);\n    }\n\n    function addModerator(address _moderator) external onlyOwner { moderators[_moderator] = true; }\n    function removeModerator(address _moderator) external onlyOwner { moderators[_moderator] = false; }\n    function updateAGITokenAddress(address _newTokenAddress) external onlyOwner whenConfigurable {\n        agiToken = IERC20(_newTokenAddress);\n    }\n    function setBaseIpfsUrl(string calldata _url) external onlyOwner whenConfigurable { baseIpfsUrl = _url; }\n    function setRequiredValidatorApprovals(uint256 _approvals) external onlyOwner whenConfigurable {\n        _validateValidatorThresholds(_approvals, requiredValidatorDisapprovals);\n        requiredValidatorApprovals = _approvals;\n    }\n    function setRequiredValidatorDisapprovals(uint256 _disapprovals) external onlyOwner whenConfigurable {\n        _validateValidatorThresholds(requiredValidatorApprovals, _disapprovals);\n        requiredValidatorDisapprovals = _disapprovals;\n    }\n    function setPremiumReputationThreshold(uint256 _threshold) external onlyOwner whenConfigurable {\n        premiumReputationThreshold = _threshold;\n    }\n    function setMaxJobPayout(uint256 _maxPayout) external onlyOwner whenConfigurable { maxJobPayout = _maxPayout; }\n    function setJobDurationLimit(uint256 _limit) external onlyOwner whenConfigurable { jobDurationLimit = _limit; }\n    function setCompletionReviewPeriod(uint256 _period) external onlyOwner whenConfigurable {\n        if (!(_period > 0 && _period <= MAX_REVIEW_PERIOD)) revert InvalidParameters();\n        uint256 oldPeriod = completionReviewPeriod;\n        completionReviewPeriod = _period;\n        emit CompletionReviewPeriodUpdated(oldPeriod, _period);\n    }\n    function setDisputeReviewPeriod(uint256 _period) external onlyOwner whenConfigurable {\n        if (!(_period > 0 && _period <= MAX_REVIEW_PERIOD)) revert InvalidParameters();\n        uint256 oldPeriod = disputeReviewPeriod;\n        disputeReviewPeriod = _period;\n        emit DisputeReviewPeriodUpdated(oldPeriod, _period);\n    }\n    function setAdditionalAgentPayoutPercentage(uint256 _percentage) external onlyOwner whenConfigurable {\n        if (!(_percentage > 0 && _percentage <= 100)) revert InvalidParameters();\n        if (_percentage > 100 - validationRewardPercentage) revert InvalidParameters();\n        additionalAgentPayoutPercentage = _percentage;\n        emit AdditionalAgentPayoutPercentageUpdated(_percentage);\n    }\n    function updateTermsAndConditionsIpfsHash(string calldata _hash) external onlyOwner whenConfigurable {\n        termsAndConditionsIpfsHash = _hash;\n    }\n    function updateContactEmail(string calldata _email) external onlyOwner whenConfigurable { contactEmail = _email; }\n    function updateAdditionalText1(string calldata _text) external onlyOwner whenConfigurable { additionalText1 = _text; }\n    function updateAdditionalText2(string calldata _text) external onlyOwner whenConfigurable { additionalText2 = _text; }\n    function updateAdditionalText3(string calldata _text) external onlyOwner whenConfigurable { additionalText3 = _text; }\n\n    function getJobStatus(uint256 _jobId) external view returns (bool, bool, string memory) {\n        Job storage job = jobs[_jobId];\n        string memory statusUri = job.jobCompletionURI;\n        return (\n            job.completed,\n            job.completionRequested,\n            bytes(statusUri).length == 0 ? job.ipfsHash : statusUri\n        );\n    }\n\n    function getJobAgentPayoutPct(uint256 _jobId) external view returns (uint256) {\n        Job storage job = _job(_jobId);\n        return job.agentPayoutPct;\n    }\n\n    /// @notice Returns the canonical job status for UI/indexing.\n    /// @dev Precedence order: Completed, Deleted, Disputed, Open, CompletionRequested, Expired, InProgress.\n    /// @dev \"Expired\" is time-derived and does not imply settlement unless expireJob is called.\n    /// @dev \"Deleted\" corresponds to the internal cancel/delete representation (employer == address(0)).\n    function jobStatus(uint256 jobId) external view returns (JobStatus) {\n        return _jobStatus(jobId);\n    }\n\n    function _jobStatus(uint256 jobId) internal view returns (JobStatus) {\n        if (jobId >= nextJobId) revert JobNotFound();\n        Job storage job = jobs[jobId];\n        if (job.completed) return JobStatus.Completed;\n        if (job.employer == address(0)) return JobStatus.Deleted;\n        if (job.disputed) return JobStatus.Disputed;\n        if (job.assignedAgent == address(0)) return JobStatus.Open;\n        if (job.completionRequested) return JobStatus.CompletionRequested;\n        if (\n            job.expired ||\n            (job.assignedAgent != address(0) &&\n                job.assignedAt != 0 &&\n                job.duration != 0 &&\n                block.timestamp > job.assignedAt + job.duration)\n        ) {\n            return JobStatus.Expired;\n        }\n        return JobStatus.InProgress;\n    }\n\n    function setValidationRewardPercentage(uint256 _percentage) external onlyOwner whenConfigurable {\n        if (!(_percentage > 0 && _percentage <= 100)) revert InvalidParameters();\n        uint256 maxPct = _maxAGITypePayoutPercentage();\n        if (maxPct > 100 - _percentage) revert InvalidParameters();\n        validationRewardPercentage = _percentage;\n    }\n\n    function calculateReputationPoints(uint256 _payout, uint256 _duration) internal pure returns (uint256) {\n        unchecked {\n            uint256 scaledPayout = _payout / 1e18;\n            uint256 payoutPoints = scaledPayout ** 3 / 1e5;\n            return log2(1 + payoutPoints * 1e6) + _duration / 10000;\n        }\n    }\n\n    function calculateValidatorReputationPoints(uint256 agentReputationGain) internal view returns (uint256) {\n        unchecked {\n            return (agentReputationGain * validationRewardPercentage) / 100;\n        }\n    }\n\n    function log2(uint x) internal pure returns (uint y) {\n        assembly {\n            x := sub(x, 1)\n            x := or(x, div(x, 0x02))\n            x := or(x, div(x, 0x04))\n            x := or(x, div(x, 0x10))\n            x := or(x, div(x, 0x100))\n            x := or(x, div(x, 0x10000))\n            x := or(x, div(x, 0x100000000))\n            x := or(x, div(x, 0x10000000000000000))\n            x := or(x, div(x, 0x100000000000000000000000000000000))\n            x := add(x, 1)\n            y := 0\n            for { let shift := 128 } gt(shift, 0) { shift := div(shift, 2) } {\n                let temp := shr(shift, x)\n                if gt(temp, 0) {\n                    x := temp\n                    y := add(y, shift)\n                }\n            }\n        }\n    }\n\n    function enforceReputationGrowth(address _user, uint256 _points) internal {\n        uint256 currentReputation = reputation[_user];\n        uint256 newReputation = currentReputation + _points;\n\n        uint256 diminishingFactor = 1 + ((newReputation * newReputation) / (88888 * 88888));\n        uint256 diminishedReputation = newReputation / diminishingFactor;\n\n        if (diminishedReputation > 88888) {\n            reputation[_user] = 88888;\n        } else {\n            reputation[_user] = diminishedReputation;\n        }\n        emit ReputationUpdated(_user, reputation[_user]);\n    }\n\n    function cancelJob(uint256 _jobId) external nonReentrant {\n        Job storage job = _job(_jobId);\n        if (msg.sender != job.employer) revert NotAuthorized();\n        if (job.completed || job.assignedAgent != address(0)) revert InvalidState();\n        _releaseEscrow(job);\n        _t(job.employer, job.payout);\n        delete jobs[_jobId];\n        emit JobCancelled(_jobId);\n    }\n\n    function expireJob(uint256 _jobId) external nonReentrant {\n        Job storage job = _job(_jobId);\n        if (job.completed || job.expired || job.disputed || job.completionRequested) revert InvalidState();\n        if (job.assignedAgent == address(0)) revert InvalidState();\n        if (block.timestamp <= job.assignedAt + job.duration) revert InvalidState();\n\n        job.expired = true;\n        _releaseEscrow(job);\n        _t(job.employer, job.payout);\n        emit JobExpired(_jobId, job.employer, job.assignedAgent, job.payout);\n    }\n\n    function finalizeJob(uint256 _jobId) external nonReentrant {\n        Job storage job = _job(_jobId);\n        if (job.completed || job.expired || job.disputed) revert InvalidState();\n        if (!job.completionRequested || job.completionRequestedAt == 0) revert InvalidState();\n        if (block.timestamp <= job.completionRequestedAt + completionReviewPeriod) revert InvalidState();\n        if (requiredValidatorDisapprovals > 0 && job.validatorDisapprovals >= requiredValidatorDisapprovals) {\n            revert InvalidState();\n        }\n\n        if (requiredValidatorApprovals > 0 && job.validatorApprovals >= requiredValidatorApprovals) {\n            _completeJob(_jobId);\n            emit JobFinalized(_jobId, job.assignedAgent, job.employer, true, job.payout);\n            return;\n        }\n\n        bool agentWins;\n        if (job.validatorApprovals == 0 && job.validatorDisapprovals == 0) {\n            agentWins = true;\n        } else {\n            agentWins = job.validatorApprovals > job.validatorDisapprovals;\n        }\n\n        if (agentWins) {\n            _completeJob(_jobId);\n        } else {\n            _refundEmployer(job);\n        }\n\n        emit JobFinalized(_jobId, job.assignedAgent, job.employer, agentWins, job.payout);\n    }\n\n    function _completeJob(uint256 _jobId) internal {\n        Job storage job = _job(_jobId);\n        if (job.completed || job.expired) revert InvalidState();\n        if (job.disputed) revert InvalidState();\n        if (job.assignedAgent == address(0)) revert InvalidState();\n        if (!job.completionRequested) revert InvalidState();\n        _requireValidUri(job.jobCompletionURI);\n\n        uint256 agentPayoutPercentage = job.agentPayoutPct;\n        if (agentPayoutPercentage == 0) revert InvalidAgentPayoutSnapshot();\n        uint256 validatorPayoutPercentage = job.validators.length > 0 ? validationRewardPercentage : 0;\n        if (agentPayoutPercentage + validatorPayoutPercentage > 100) revert InvalidParameters();\n        uint256 agentPayout;\n        unchecked {\n            agentPayout = (job.payout * agentPayoutPercentage) / 100;\n        }\n        uint256 totalValidatorPayout = 0;\n        if (job.validators.length > 0) {\n            unchecked {\n                totalValidatorPayout = (job.payout * validationRewardPercentage) / 100;\n            }\n        }\n        if (agentPayout + totalValidatorPayout > job.payout) revert InvalidParameters();\n\n        job.completed = true;\n        job.disputed = false;\n        _releaseEscrow(job);\n\n        uint256 completionTime = block.timestamp - job.assignedAt;\n        uint256 reputationPoints = calculateReputationPoints(job.payout, completionTime);\n        enforceReputationGrowth(job.assignedAgent, reputationPoints);\n\n        _payAgent(job);\n        _payValidators(job, reputationPoints);\n        _mintJobNft(job);\n\n        emit JobCompleted(_jobId, job.assignedAgent, reputationPoints);\n        emit ReputationUpdated(job.assignedAgent, reputation[job.assignedAgent]);\n    }\n\n    function _refundEmployer(Job storage job) internal {\n        job.completed = true;\n        job.disputed = false;\n        job.disputedAt = 0;\n        _releaseEscrow(job);\n        _t(job.employer, job.payout);\n    }\n\n    function _payAgent(Job storage job) internal {\n        uint256 agentPayoutPercentage = job.agentPayoutPct;\n        if (agentPayoutPercentage == 0) revert InvalidAgentPayoutSnapshot();\n        uint256 agentPayout;\n        unchecked {\n            agentPayout = (job.payout * agentPayoutPercentage) / 100;\n        }\n        _t(job.assignedAgent, agentPayout);\n    }\n\n    function _payValidators(Job storage job, uint256 reputationPoints) internal {\n        uint256 vCount = job.validators.length;\n        if (vCount > MAX_VALIDATORS_PER_JOB) revert ValidatorSetTooLarge();\n        if (vCount == 0) return;\n\n        uint256 totalValidatorPayout;\n        uint256 validatorPayout;\n        unchecked {\n            totalValidatorPayout = (job.payout * validationRewardPercentage) / 100;\n            validatorPayout = totalValidatorPayout / vCount;\n        }\n        uint256 validatorReputationGain = calculateValidatorReputationPoints(reputationPoints);\n\n        for (uint256 i = 0; i < vCount; ) {\n            address validator = job.validators[i];\n            _t(validator, validatorPayout);\n            enforceReputationGrowth(validator, validatorReputationGain);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _mintJobNft(Job storage job) internal {\n        uint256 tokenId = nextTokenId;\n        unchecked {\n            ++nextTokenId;\n        }\n        _requireValidUri(job.jobCompletionURI);\n        string memory tokenUriValue = _formatTokenURI(job.jobCompletionURI);\n        _mint(job.employer, tokenId);\n        _setTokenURI(tokenId, tokenUriValue);\n        emit NFTIssued(tokenId, job.employer, tokenUriValue);\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireMinted(tokenId);\n        return _tokenURIs[tokenId];\n    }\n\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal {\n        _requireMinted(tokenId);\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    function _formatTokenURI(string memory uri) internal view returns (string memory) {\n        if (_isFullUri(uri)) {\n            return uri;\n        }\n        if (bytes(baseIpfsUrl).length == 0) {\n            return uri;\n        }\n        return string(abi.encodePacked(baseIpfsUrl, \"/\", uri));\n    }\n\n    function _isFullUri(string memory uri) internal pure returns (bool) {\n        bytes memory data = bytes(uri);\n        if (data.length < 3) return false;\n        for (uint256 i = 0; i + 2 < data.length; ) {\n            if (data[i] == \":\" && data[i + 1] == \"/\" && data[i + 2] == \"/\") {\n                return true;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return false;\n    }\n\n    function _requireValidUri(string memory uri) internal pure {\n        bytes memory data = bytes(uri);\n        if (data.length == 0) revert InvalidParameters();\n        for (uint256 i = 0; i < data.length; ) {\n            bytes1 c = data[i];\n            if (c == 0x20 || c == 0x09 || c == 0x0a || c == 0x0d) revert InvalidParameters();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function listNFT(uint256 tokenId, uint256 price) external whenNotPaused {\n        if (ownerOf(tokenId) != msg.sender) revert NotAuthorized();\n        if (price == 0) revert InvalidParameters();\n        listings[tokenId] = Listing(tokenId, msg.sender, price, true);\n        emit NFTListed(tokenId, msg.sender, price);\n    }\n\n    function purchaseNFT(uint256 tokenId) external whenNotPaused nonReentrant {\n        Listing storage listing = listings[tokenId];\n        if (!listing.isActive) revert InvalidState();\n        address seller = listing.seller;\n        uint256 price = listing.price;\n        if (seller == address(0)) revert InvalidState();\n        if (seller == msg.sender) revert NotAuthorized();\n        if (price == 0) revert InvalidParameters();\n        if (ownerOf(tokenId) != seller) revert InvalidState();\n        listing.isActive = false;\n        _tFrom(msg.sender, seller, price);\n        _safeTransfer(seller, msg.sender, tokenId, \"\");\n        emit NFTPurchased(tokenId, msg.sender, price);\n    }\n\n    function delistNFT(uint256 tokenId) external whenNotPaused {\n        Listing storage listing = listings[tokenId];\n        if (!listing.isActive || listing.seller != msg.sender) revert NotAuthorized();\n        listing.isActive = false;\n        emit NFTDelisted(tokenId);\n    }\n\n    function _verifyOwnershipAgent(address claimant, string memory subdomain, bytes32[] calldata proof)\n        internal\n        returns (bool)\n    {\n        bytes32 leaf = keccak256(abi.encodePacked(claimant));\n        if (proof.verify(agentMerkleRoot, leaf)) {\n            emit OwnershipVerified(claimant, subdomain);\n            return true;\n        }\n        if (_verifyEnsOwnership(claimant, subdomain, agentRootNode)) return true;\n        if (_verifyEnsOwnership(claimant, subdomain, agentRootNodeAlpha)) return true;\n        return false;\n    }\n\n    function _verifyOwnershipValidator(address claimant, string memory subdomain, bytes32[] calldata proof)\n        internal\n        returns (bool)\n    {\n        bytes32 leaf = keccak256(abi.encodePacked(claimant));\n        if (proof.verify(validatorMerkleRoot, leaf)) {\n            emit OwnershipVerified(claimant, subdomain);\n            return true;\n        }\n        if (_verifyEnsOwnership(claimant, subdomain, clubRootNode)) return true;\n        if (_verifyEnsOwnership(claimant, subdomain, clubRootNodeAlpha)) return true;\n        return false;\n    }\n\n    function _verifyEnsOwnership(address claimant, string memory subdomain, bytes32 rootNode) internal returns (bool) {\n        if (rootNode == bytes32(0)) return false;\n        bytes32 subnode = keccak256(abi.encodePacked(rootNode, keccak256(bytes(subdomain))));\n        if (_verifyNameWrapperOwnership(claimant, subnode)) {\n            emit OwnershipVerified(claimant, subdomain);\n            return true;\n        }\n        if (_verifyResolverOwnership(claimant, subnode)) {\n            emit OwnershipVerified(claimant, subdomain);\n            return true;\n        }\n        return false;\n    }\n\n    function _verifyNameWrapperOwnership(address claimant, bytes32 subnode) internal returns (bool) {\n        try nameWrapper.ownerOf(uint256(subnode)) returns (address actualOwner) {\n            return actualOwner == claimant;\n        } catch {\n            emit RecoveryInitiated(\"NW_FAIL\");\n        }\n        return false;\n    }\n\n    function _verifyResolverOwnership(address claimant, bytes32 subnode) internal returns (bool) {\n        address resolverAddress = ens.resolver(subnode);\n        if (resolverAddress == address(0)) {\n            emit RecoveryInitiated(\"NO_RES\");\n            return false;\n        }\n\n        Resolver resolver = Resolver(resolverAddress);\n        try resolver.addr(subnode) returns (address payable resolvedAddress) {\n            return resolvedAddress == claimant;\n        } catch {\n            emit RecoveryInitiated(\"RES_FAIL\");\n        }\n        return false;\n    }\n\n    function addAdditionalValidator(address validator) external onlyOwner whenConfigurable { additionalValidators[validator] = true; }\n    function removeAdditionalValidator(address validator) external onlyOwner whenConfigurable { additionalValidators[validator] = false; }\n    function addAdditionalAgent(address agent) external onlyOwner whenConfigurable { additionalAgents[agent] = true; }\n    function removeAdditionalAgent(address agent) external onlyOwner whenConfigurable { additionalAgents[agent] = false; }\n\n    function withdrawableAGI() public view returns (uint256) {\n        uint256 bal = agiToken.balanceOf(address(this));\n        if (bal < lockedEscrow) revert InsolventEscrowBalance();\n        return bal - lockedEscrow;\n    }\n\n    function withdrawAGI(uint256 amount) external onlyOwner whenPaused nonReentrant {\n        if (amount == 0) revert InvalidParameters();\n        uint256 available = withdrawableAGI();\n        if (amount > available) revert InsufficientWithdrawableBalance();\n        _t(msg.sender, amount);\n        emit AGIWithdrawn(msg.sender, amount, available - amount);\n    }\n\n    function canAccessPremiumFeature(address user) public view returns (bool) {\n        return reputation[user] >= premiumReputationThreshold;\n    }\n\n    function contributeToRewardPool(uint256 amount) external whenNotPaused nonReentrant {\n        if (amount == 0) revert InvalidParameters();\n        _safeERC20TransferFromExact(agiToken, msg.sender, address(this), amount);\n        emit RewardPoolContribution(msg.sender, amount);\n    }\n\n    function addAGIType(address nftAddress, uint256 payoutPercentage) external onlyOwner whenConfigurable {\n        if (!(nftAddress != address(0) && payoutPercentage > 0 && payoutPercentage <= 100)) revert InvalidParameters();\n\n        uint256 maxPct = payoutPercentage;\n        bool exists = false;\n        for (uint256 i = 0; i < agiTypes.length; ) {\n            uint256 pct = agiTypes[i].payoutPercentage;\n            if (agiTypes[i].nftAddress == nftAddress) {\n                pct = payoutPercentage;\n                exists = true;\n            }\n            if (pct > maxPct) {\n                maxPct = pct;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        if (maxPct > 100 - validationRewardPercentage) revert InvalidParameters();\n        if (!exists) {\n            agiTypes.push(AGIType({ nftAddress: nftAddress, payoutPercentage: payoutPercentage }));\n        } else {\n            for (uint256 i = 0; i < agiTypes.length; ) {\n                if (agiTypes[i].nftAddress == nftAddress) {\n                    agiTypes[i].payoutPercentage = payoutPercentage;\n                    break;\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        emit AGITypeUpdated(nftAddress, payoutPercentage);\n    }\n\n    function getHighestPayoutPercentage(address agent) public view returns (uint256) {\n        uint256 highestPercentage = 0;\n        for (uint256 i = 0; i < agiTypes.length; ) {\n            if (IERC721(agiTypes[i].nftAddress).balanceOf(agent) > 0 && agiTypes[i].payoutPercentage > highestPercentage) {\n                highestPercentage = agiTypes[i].payoutPercentage;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return highestPercentage;\n    }\n}\n"},"contracts/legacy/AGIJobManagerOriginal.sol":{"content":"// SPDX-License-Identifier: MIT\n\n/*\n\n[ P R E L I M I N A R Y  C O N C E P T S  E X C L U S I V E L Y ]\n\nOF AGENTS, NODES, AND TOKENS\n\nThe Economy of AGI\n\nAGI Nodes are catalysts in this new economy.\n\nThey yield $AGI, bridging the gap between aspirations and achievements.\n\nLike digital farmers in a vast cognitive field, they cultivate the future.\n\n\"Unleash the power of Decentralized AGI with AGI Agents & Nodes, and unlock the future.\" - AGI.eth\n\nShould it ascend to its fullest potential, $AGI stands poised to crystallize a vital segment of AGI's projected astronomic value.\n\n           \n   A   N   T   N   A   T\n -------------------------\nA   G   I   N   O   D   E   S\n -------------------------\n   T   A   N   A   T   N\n\n\n$AGI: UTILITY, PURPOSE & VALUE\n\nAGI Agents x AGI Nodes = Decentralized AGI\n\nTheoretically, AGI Agents have the potential to become the central architects of future value, laying the foundation for The Economy of AGI.\n\nAt the heart of the Economy of AGI are the AGI Nodes. These Nodes, represented as Non-Fungible Tokens (NFTs), embody the ownership of computational assets. They provide AGI Agents with a decentralized, extensive, and powerful collection of computational resources. The sole raison d'être of the AGI Nodes is to contribute to the AGI Network. $AGI tokens are created solely through the operation of an AGI Node, generating active income only for the contribution of computational resources to the network. Crucially, holding $AGI tokens neither constitutes an investment in a common enterprise nor offers any expectation of profits derived from the efforts of others. Rather, $AGI tokens are minted as a reward for contributing computational resources, aligning more with the characteristics of a utility token than a security. The purpose is straightforward: to power the network, not to speculate on its future value.\n\nWhen timely and appropriate, $AGI tokens—strictly utility tokens—can be used to acquire products or services generated by AGI Agents within the Economy of AGI framework, often represented as NFTs.\n\nLegal Addendum: $AGI tokens are not securities and are not intended for speculative investment. They do not represent equity ownership, confer voting rights, or entitle holders to dividends or a share of profits. They are engineered exclusively for utility functions within the AGI Network, specifically for operating an AGI Node in order to contribute to the AGI Network, and for acquiring an array of products and services generated by AGI Agents.\n\n[ C O N C E P T U A L  S T O R Y ]\n\nTHE ECONOMY OF AGI: AGI AGENTS, NODES AND TOKENS\n\nIn the expansive cosmos of human progress, seismic shifts occur, heralding eras that brim with promise and teem with unimagined potentials.\n\nThe Advent of the AGI Agents\n\nImagine beings of digital cognition, capable of performing any task a person can undertake with a computer, yet unbounded by our constraints. Far from being mere figments in the digital landscape, these entities serve as the crucibles of a transformative shift, igniting the intellectual abundance that will reshape our future.\n\nA Symbiosis: AGI Agents and AGI Nodes\n\nWhile seemingly independent, AGI Agents are entwined in a delicate pas de deux with AGI Nodes—the bedrock providing the resources for these Agents to operate. Consider these Nodes the landlords of digital landscapes, commanding a formidable arsenal of computational might that AGI Agents leverage to weave value. This intricate ballet underscores a web of interconnected fate, with each entity's existence intrinsically tied to the other's operation.\n\nThe Economy of AGI: $AGI Tokens and NFTs\n\nWithin this cavalcade of ingenuity emerges a groundbreaking financial architecture, introducing the $AGI token as a medium for operational transactions within the network. Derived from the relentless operation of AGI Nodes, the $AGI token represents a visionary chronicle where cognition has transcended traditional boundaries, redefining the established yardsticks of wealth and ambition. This token serves as the universal medium for acquiring an array of products and services, the labor of the AGI Agents manifesting in the form of unique NFTs.\n\nThe Ethical Layer: Ensuring Accountability\n\nAs we voyage into this new era, anchoring our inventions in ethical terra firma becomes non-negotiable. To this end, each AGI Agent and Node is assigned its own ENSOriginal AGI subdomain, a beacon of trust that ensures each Agent and Node operates within the boundaries of ethical AI, all within a system architected to uphold ethical norms.\n\nMitigating the Unemployment Conundrum\n\nA critical consideration in this transformative journey is the potential unemployment that AGI could inadvertently cause. The key to disentangling this Gordian knot lies in the democratization of ownership—AGI Agents and AGI Nodes can be owned, and hence, can provide a hedge against the risk of unemployment. These entities, when operated, can generate substantial utility and value within the network.\n\nA Sovereign Future\n\nOur future thus unfurls as a panorama of limitless potential. As sovereign entities, AGI Agents and Nodes orchestrate a coming age where the triad of privacy, personalization, and potency find harmonic unity.\n\nIn this mesmerizing narrative, we all emerge as pioneers, architects of a societal model vibrating with untapped intellectual prowess. The age of AGI Agents is not a distant dream but our shared horizon. Let's embrace the Economy of AGI Agents, a venture into the annals of human endeavor unlike any before.\n\n\"AGI symbolizes the linchpin that connects the boundless potential of our aspirations to the tangible confines of reality, fashioning a gateway between the fanciful musings of the mind and the attainable horizons of success.\" - AGI.eth\n\n[ R E G U L A T O R Y  C O M P L I A N C E  &  L E G A L  D I S C L O S U R E S ]\n\nPublished by: AGI.eth\n\nApproval Authority: AGI.eth\n\nOffice of Primary Responsibility: AGI.eth\n\n1. Utility Token Clause: The $AGI token is intrinsically designed to enable active participation in the AGI Network, exclusively facilitating transactions and operational tasks within this ecosystem.\n\n2. No Expectation of Profit: $AGI tokens are created solely through active node operation, with any financial gains being incidental and non-guaranteed. These tokens are not for speculative investment but for facilitating specific actions within the AGI Network.\n\n3. No Ownership or Voting Rights: Holding $AGI tokens confers no ownership, shares, equity, or voting rights in any entity associated with AGI.eth or the AGI Network.\n\n4. No Common Enterprise: $AGI tokens serve as individual operational assets and are not an investment in a common enterprise, as defined by securities laws.\n\n5. Active Participation: $AGI tokens are minted only through active participation, which involves contributing computational resources to the network.\n\n6. No Financial Entitlement: Holding $AGI tokens does not grant entitlement to dividends, revenue-sharing, or any financial benefits; they are not designed for investment.\n\n7. User Acknowledgment: All users must expressly acknowledge that $AGI tokens are not securities and do not confer financial benefits. This acknowledgment is legally binding and constitutes part of the User Agreement Requirement.\n\n8. User Agreement Requirement: All users interacting with this contract are required to agree to the Terms of Service, which provide further legal and ethical guidelines, including the non-security nature of $AGI tokens.\n\nTHIS IS PART OF AN ASPIRATIONAL RESEARCH PROGRAM WITH AN AMBITIOUS RESEARCH AGENDA. AGI AGENTS AND AGI NODES ARE COMMODITIES. THEY ARE LIKELY RETAILED BY DISTINCT OPERATING INTERNATIONAL ENTITIES ESTABLISHED AS APPROPRIATE IN SPACE AND TIME. WHILE, AS INDUCEMENTS FOR OPERATION, AGI NODES MAY OFFER THE PROSPECT OF EARNING $AGI, WHICH IS MOST LIKELY MANAGED BY A SERIES OF DISTINCT FOUNDATIONS OR ORGANIZATIONS ESTABLISHED WHEN AND WHERE APPROPRIATE, ANY EXPECTATION OF PROFIT OR RETURN IS UNJUSTIFIED. POSSESSION OF $AGI OR OF AN AGI AGENT OR OF AN AGI NODE DOES NOT SIGNIFY OR ESTABLISH ANY ENTITLEMENT OR INTEREST, SHARE OR EQUITY, BOND OR ANALOGOUS ENTITLEMENT, OR ANY RIGHT TO OBTAIN ANY FUTURE INCOME. MATERIALS PROVIDED IN THIS SYSTEM ARE WITHOUT WARRANTY OF ANY KIND AND DO NOT CONSTITUTE ENDORSEMENT AND CAN BE MODIFIED AT ANY TIME. BY USING THE PRESENT SYSTEM, YOU AGREE TO THE $AGI TERMS AND CONDITIONS. ANY USE OF THIS SYSTEM, OR ANY OF THE INFORMATION CONTAINED HEREIN, FOR OTHER THAN THE PURPOSE FOR WHICH IT WAS DEVELOPED, IS EXPRESSLY PROHIBITED, EXCEPT AS AGI.ETH MAY OTHERWISE AGREE TO IN WRITING OFFICIALLY.\n\nOVERRIDING AUTHORITY: AGI.ETH\n   \n*/\n\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\ninterface ENSOriginal {\n    function resolver(bytes32 node) external view returns (address);\n}\n\ninterface ResolverOriginal {\n    function addr(bytes32 node) external view returns (address payable);\n}\n\ninterface NameWrapperOriginal {\n    function ownerOf(uint256 id) external view returns (address);\n}\n\ncontract AGIJobManagerOriginal is Ownable, ReentrancyGuard, Pausable, ERC721URIStorage {\n    using ECDSA for bytes32;\n    using MerkleProof for bytes32[];\n\n    IERC20 public agiToken;\n    string private baseIpfsUrl;\n    uint256 public requiredValidatorApprovals = 3;\n    uint256 public requiredValidatorDisapprovals = 3;\n    uint256 public premiumReputationThreshold = 10000;\n    uint256 public validationRewardPercentage = 8;\n    uint256 public maxJobPayout = 4888e18;\n    uint256 public jobDurationLimit = 10000000;\n\n    string public termsAndConditionsIpfsHash;\n    string public contactEmail;\n    string public additionalText1;\n    string public additionalText2;\n    string public additionalText3;\n\n    bytes32 public clubRootNode;\n    bytes32 public agentRootNode;\n    bytes32 public validatorMerkleRoot;\n    bytes32 public agentMerkleRoot;\n    ENSOriginal public ens;\n    NameWrapperOriginal public nameWrapper;\n\n    struct Job {\n        uint256 id;\n        address employer;\n        string ipfsHash;\n        uint256 payout;\n        uint256 duration;\n        address assignedAgent;\n        uint256 assignedAt;\n        bool completed;\n        bool completionRequested;\n        uint256 validatorApprovals;\n        uint256 validatorDisapprovals;\n        bool disputed;\n        string details;\n        mapping(address => bool) approvals;\n        mapping(address => bool) disapprovals;\n        address[] validators;\n    }\n\n    struct AGIType {\n        address nftAddress;\n        uint256 payoutPercentage;\n    }\n\n    struct Listing {\n        uint256 tokenId;\n        address seller;\n        uint256 price;\n        bool isActive;\n    }\n\n    uint256 public nextJobId;\n    uint256 public nextTokenId;\n    mapping(uint256 => Job) public jobs;\n    mapping(address => uint256) public reputation;\n    mapping(address => bool) public moderators;\n    mapping(address => bool) public additionalValidators;\n    mapping(address => bool) public additionalAgents;\n    mapping(address => uint256[]) public validatorApprovedJobs;\n    mapping(uint256 => Listing) public listings;\n    mapping(address => bool) public blacklistedAgents;\n    mapping(address => bool) public blacklistedValidators;\n    AGIType[] public agiTypes;\n\n    event JobCreated(uint256 jobId, string ipfsHash, uint256 payout, uint256 duration, string details);\n    event JobApplied(uint256 jobId, address agent);\n    event JobCompletionRequested(uint256 jobId, address agent);\n    event JobValidated(uint256 jobId, address validator);\n    event JobDisapproved(uint256 jobId, address validator);\n    event JobCompleted(uint256 jobId, address agent, uint256 reputationPoints);\n    event ReputationUpdated(address user, uint256 newReputation);\n    event JobCancelled(uint256 jobId);\n    event DisputeResolved(uint256 jobId, address resolver, string resolution);\n    event JobDisputed(uint256 jobId, address disputant);\n    event RootNodeUpdated(bytes32 indexed newRootNode);\n    event MerkleRootUpdated(bytes32 indexed newMerkleRoot);\n    event OwnershipVerified(address claimant, string subdomain);\n    event RecoveryInitiated(string reason);\n    event AGITypeUpdated(address indexed nftAddress, uint256 payoutPercentage);\n    event NFTIssued(uint256 indexed tokenId, address indexed employer, string tokenURI);\n    event NFTListed(uint256 indexed tokenId, address indexed seller, uint256 price);\n    event NFTPurchased(uint256 indexed tokenId, address indexed buyer, uint256 price);\n    event NFTDelisted(uint256 indexed tokenId);\n    event RewardPoolContribution(address indexed contributor, uint256 amount);\n\n    constructor(\n        address _agiTokenAddress,\n        string memory _baseIpfsUrl,\n        address _ensAddress,\n        address _nameWrapperAddress,\n        bytes32 _clubRootNode,\n        bytes32 _agentRootNode,\n        bytes32 _validatorMerkleRoot,\n        bytes32 _agentMerkleRoot\n    ) ERC721(\"AGIJobs\", \"Job\") {\n        agiToken = IERC20(_agiTokenAddress);\n        baseIpfsUrl = _baseIpfsUrl;\n        ens = ENSOriginal(_ensAddress);\n        nameWrapper = NameWrapperOriginal(_nameWrapperAddress);\n        clubRootNode = _clubRootNode;\n        agentRootNode = _agentRootNode;\n        validatorMerkleRoot = _validatorMerkleRoot;\n        agentMerkleRoot = _agentMerkleRoot;\n    }\n\n    modifier onlyModerator() {\n        require(moderators[msg.sender], \"Not a moderator\");\n        _;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function createJob(string memory _ipfsHash, uint256 _payout, uint256 _duration, string memory _details) external whenNotPaused nonReentrant {\n        require(_payout > 0 && _duration > 0 && _payout <= maxJobPayout && _duration <= jobDurationLimit, \"Invalid job parameters\");\n        uint256 jobId = nextJobId++;\n        Job storage job = jobs[jobId];\n        job.id = jobId;\n        job.employer = msg.sender;\n        job.ipfsHash = _ipfsHash;\n        job.payout = _payout;\n        job.duration = _duration;\n        job.details = _details;\n        require(agiToken.transferFrom(msg.sender, address(this), _payout), \"Escrow payment failed\");\n        emit JobCreated(jobId, _ipfsHash, _payout, _duration, _details);\n    }\n\n    function applyForJob(uint256 _jobId, string memory subdomain, bytes32[] calldata proof) external whenNotPaused nonReentrant {\n        Job storage job = jobs[_jobId];\n        require(job.assignedAgent == address(0), \"Job already assigned\");\n        require((_verifyOwnership(msg.sender, subdomain, proof, agentRootNode) || additionalAgents[msg.sender]) && !blacklistedAgents[msg.sender], \"Not authorized agent\");\n        job.assignedAgent = msg.sender;\n        job.assignedAt = block.timestamp;\n        emit JobApplied(_jobId, msg.sender);\n    }\n\n    function requestJobCompletion(uint256 _jobId, string calldata _ipfsHash) external whenNotPaused {\n        Job storage job = jobs[_jobId];\n        require(msg.sender == job.assignedAgent && block.timestamp <= job.assignedAt + job.duration, \"Not authorized or expired\");\n        job.ipfsHash = _ipfsHash;\n        job.completionRequested = true;\n        emit JobCompletionRequested(_jobId, msg.sender);\n    }\n\n    function validateJob(uint256 _jobId, string memory subdomain, bytes32[] calldata proof) external whenNotPaused nonReentrant {\n        require(_verifyOwnership(msg.sender, subdomain, proof, clubRootNode) || additionalValidators[msg.sender], \"Not authorized validator\");\n        require(!blacklistedValidators[msg.sender], \"Blacklisted validator\");\n        Job storage job = jobs[_jobId];\n        require(!job.completed && !job.approvals[msg.sender], \"Job completed or already approved\");\n        job.validatorApprovals++;\n        job.approvals[msg.sender] = true;\n        job.validators.push(msg.sender);\n        validatorApprovedJobs[msg.sender].push(_jobId);\n        emit JobValidated(_jobId, msg.sender);\n        if (job.validatorApprovals >= requiredValidatorApprovals) _completeJob(_jobId);\n    }\n\n    function disapproveJob(uint256 _jobId, string memory subdomain, bytes32[] calldata proof) external whenNotPaused nonReentrant {\n        require(_verifyOwnership(msg.sender, subdomain, proof, clubRootNode) || additionalValidators[msg.sender], \"Not authorized validator\");\n        require(!blacklistedValidators[msg.sender], \"Blacklisted validator\");\n        Job storage job = jobs[_jobId];\n        require(!job.completed && !job.disapprovals[msg.sender], \"Job completed or already disapproved\");\n        job.validatorDisapprovals++;\n        job.disapprovals[msg.sender] = true;\n        job.validators.push(msg.sender);\n        validatorApprovedJobs[msg.sender].push(_jobId);\n        emit JobDisapproved(_jobId, msg.sender);\n        if (job.validatorDisapprovals >= requiredValidatorDisapprovals) {\n            job.disputed = true;\n            emit JobDisputed(_jobId, msg.sender);\n        }\n    }\n\n    function disputeJob(uint256 _jobId) external whenNotPaused nonReentrant {\n        Job storage job = jobs[_jobId];\n        require((msg.sender == job.assignedAgent || msg.sender == job.employer) && !job.disputed && !job.completed, \"Not authorized or invalid state\");\n        job.disputed = true;\n        emit JobDisputed(_jobId, msg.sender);\n    }\n\n    function resolveDispute(uint256 _jobId, string calldata resolution) external onlyModerator nonReentrant {\n        Job storage job = jobs[_jobId];\n        require(job.disputed, \"Job not disputed\");\n        if (keccak256(abi.encodePacked(resolution)) == keccak256(abi.encodePacked(\"agent win\"))) {\n            _completeJob(_jobId);\n        } else if (keccak256(abi.encodePacked(resolution)) == keccak256(abi.encodePacked(\"employer win\"))) {\n            agiToken.transfer(job.employer, job.payout);\n        }\n        job.disputed = false;\n        emit DisputeResolved(_jobId, msg.sender, resolution);\n    }\n\n    function blacklistAgent(address _agent, bool _status) external onlyOwner {\n        blacklistedAgents[_agent] = _status;\n    }\n\n    function blacklistValidator(address _validator, bool _status) external onlyOwner {\n        blacklistedValidators[_validator] = _status;\n    }\n\n    function delistJob(uint256 _jobId) external onlyOwner {\n        Job storage job = jobs[_jobId];\n        require(!job.completed && job.assignedAgent == address(0), \"Job already completed or assigned\");\n        agiToken.transfer(job.employer, job.payout);\n        delete jobs[_jobId];\n        emit JobCancelled(_jobId);\n    }\n\n    function addModerator(address _moderator) external onlyOwner {\n        moderators[_moderator] = true;\n    }\n\n    function removeModerator(address _moderator) external onlyOwner {\n        moderators[_moderator] = false;\n    }\n\n    function updateAGITokenAddress(address _newTokenAddress) external onlyOwner {\n        agiToken = IERC20(_newTokenAddress);\n    }\n\n    function setBaseIpfsUrl(string calldata _url) external onlyOwner {\n        baseIpfsUrl = _url;\n    }\n\n    function setRequiredValidatorApprovals(uint256 _approvals) external onlyOwner {\n        requiredValidatorApprovals = _approvals;\n    }\n\n    function setRequiredValidatorDisapprovals(uint256 _disapprovals) external onlyOwner {\n        requiredValidatorDisapprovals = _disapprovals;\n    }\n\n    function setPremiumReputationThreshold(uint256 _threshold) external onlyOwner {\n        premiumReputationThreshold = _threshold;\n    }\n\n    function setMaxJobPayout(uint256 _maxPayout) external onlyOwner {\n        maxJobPayout = _maxPayout;\n    }\n\n    function setJobDurationLimit(uint256 _limit) external onlyOwner {\n        jobDurationLimit = _limit;\n    }\n\n    function updateTermsAndConditionsIpfsHash(string calldata _hash) external onlyOwner {\n        termsAndConditionsIpfsHash = _hash;\n    }\n\n    function updateContactEmail(string calldata _email) external onlyOwner {\n        contactEmail = _email;\n    }\n\n    function updateAdditionalText1(string calldata _text) external onlyOwner {\n        additionalText1 = _text;\n    }\n\n    function updateAdditionalText2(string calldata _text) external onlyOwner {\n        additionalText2 = _text;\n    }\n\n    function updateAdditionalText3(string calldata _text) external onlyOwner {\n        additionalText3 = _text;\n    }\n\n    function getJobStatus(uint256 _jobId) external view returns (bool, bool, string memory) {\n        Job storage job = jobs[_jobId];\n        return (job.completed, job.completionRequested, job.ipfsHash);\n    }\n\n    function setValidationRewardPercentage(uint256 _percentage) external onlyOwner {\n        require(_percentage > 0 && _percentage <= 100, \"Invalid percentage\");\n        validationRewardPercentage = _percentage;\n    }\n\n    function calculateReputationPoints(uint256 _payout, uint256 _duration) internal pure returns (uint256) {\n        uint256 scaledPayout = _payout / 1e18;\n        uint256 payoutPoints = scaledPayout ** 3 / 1e5;\n        return log2(1 + payoutPoints * 1e6) + _duration / 10000;\n    }\n\n    function calculateValidatorReputationPoints(uint256 agentReputationGain) internal view returns (uint256) {\n        return (agentReputationGain * validationRewardPercentage) / 100;\n    }\n\n    function log2(uint x) internal pure returns (uint y) {\n        assembly {\n            let arg := x\n            x := sub(x, 1)\n            x := or(x, div(x, 0x02))\n            x := or(x, div(x, 0x04))\n            x := or(x, div(x, 0x10))\n            x := or(x, div(x, 0x100))\n            x := or(x, div(x, 0x10000))\n            x := or(x, div(x, 0x100000000))\n            x := or(x, div(x, 0x10000000000000000))\n            x := or(x, div(x, 0x100000000000000000000000000000000))\n            x := add(x, 1)\n            y := 0\n            for { let shift := 128 } gt(shift, 0) { shift := div(shift, 2) } {\n                let temp := shr(shift, x)\n                if gt(temp, 0) {\n                    x := temp\n                    y := add(y, shift)\n                }\n            }\n        }\n    }\n\n    function enforceReputationGrowth(address _user, uint256 _points) internal {\n        uint256 currentReputation = reputation[_user];\n        uint256 newReputation = currentReputation + _points;\n\n        // Apply diminishing return: soft at low, strong near max\n        uint256 diminishingFactor = 1 + ((newReputation * newReputation) / (88888 * 88888));\n        uint256 diminishedReputation = newReputation / diminishingFactor;\n\n        if (diminishedReputation > 88888) {\n            reputation[_user] = 88888;\n        } else {\n            reputation[_user] = diminishedReputation;\n        }\n        emit ReputationUpdated(_user, reputation[_user]);\n    }\n\n    function cancelJob(uint256 _jobId) external nonReentrant {\n        Job storage job = jobs[_jobId];\n        require(msg.sender == job.employer && !job.completed && job.assignedAgent == address(0), \"Not authorized or already completed/assigned\");\n        agiToken.transfer(job.employer, job.payout);\n        delete jobs[_jobId];\n        emit JobCancelled(_jobId);\n    }\n\n    function _completeJob(uint256 _jobId) internal {\n        Job storage job = jobs[_jobId];\n        job.completed = true;\n        uint256 completionTime = block.timestamp - job.assignedAt;\n        uint256 reputationPoints = calculateReputationPoints(job.payout, completionTime);\n        enforceReputationGrowth(job.assignedAgent, reputationPoints);\n\n        _payAgent(job);\n        _payValidators(job, reputationPoints);\n        _mintJobNft(job);\n\n        emit JobCompleted(_jobId, job.assignedAgent, reputationPoints);\n        emit ReputationUpdated(job.assignedAgent, reputation[job.assignedAgent]);\n    }\n\n    function _payAgent(Job storage job) internal {\n        uint256 agentPayoutPercentage = getHighestPayoutPercentage(job.assignedAgent);\n        uint256 agentPayout = (job.payout * agentPayoutPercentage) / 100;\n\n        require(agiToken.transfer(job.assignedAgent, agentPayout), \"Payment to agent failed\");\n    }\n\n    function _payValidators(Job storage job, uint256 reputationPoints) internal {\n        uint256 totalValidatorPayout = (job.payout * validationRewardPercentage) / 100;\n        uint256 validatorPayout = totalValidatorPayout / job.validators.length;\n        uint256 validatorReputationGain = calculateValidatorReputationPoints(reputationPoints);\n\n        for (uint256 i = 0; i < job.validators.length; i++) {\n            address validator = job.validators[i];\n            require(agiToken.transfer(validator, validatorPayout), \"Payment to validator failed\");\n            enforceReputationGrowth(validator, validatorReputationGain);\n        }\n    }\n\n    function _mintJobNft(Job storage job) internal {\n        uint256 tokenId = nextTokenId++;\n        string memory tokenURI = string(abi.encodePacked(baseIpfsUrl, \"/\", job.ipfsHash));\n        _mint(job.employer, tokenId);\n        _setTokenURI(tokenId, tokenURI);\n        emit NFTIssued(tokenId, job.employer, tokenURI);\n    }\n\n    function listNFT(uint256 tokenId, uint256 price) external {\n        require(ownerOf(tokenId) == msg.sender && price > 0, \"Not authorized or invalid price\");\n        listings[tokenId] = Listing(tokenId, msg.sender, price, true);\n        emit NFTListed(tokenId, msg.sender, price);\n    }\n\n    function purchaseNFT(uint256 tokenId) external {\n        Listing storage listing = listings[tokenId];\n        require(listing.isActive, \"Listing not active\");\n        require(agiToken.transferFrom(msg.sender, listing.seller, listing.price), \"Payment failed\");\n        _transfer(listing.seller, msg.sender, tokenId);\n        listing.isActive = false;\n        emit NFTPurchased(tokenId, msg.sender, listing.price);\n    }\n\n    function delistNFT(uint256 tokenId) external {\n        Listing storage listing = listings[tokenId];\n        require(listing.isActive && listing.seller == msg.sender, \"Not authorized or listing not active\");\n        listing.isActive = false;\n        emit NFTDelisted(tokenId);\n    }\n\n    function _verifyOwnership(address claimant, string memory subdomain, bytes32[] calldata proof, bytes32 rootNode) internal returns (bool) {\n        bytes32 leaf = keccak256(abi.encodePacked(claimant));\n        if (proof.verify(rootNode == agentRootNode ? agentMerkleRoot : validatorMerkleRoot, leaf)) {\n            emit OwnershipVerified(claimant, subdomain);\n            return true;\n        }\n\n        bytes32 subnode = keccak256(abi.encodePacked(rootNode, keccak256(bytes(subdomain))));\n        try nameWrapper.ownerOf(uint256(subnode)) returns (address actualOwner) {\n            if (actualOwner == claimant) {\n                emit OwnershipVerified(claimant, subdomain);\n                return true;\n            }\n        } catch Error(string memory reason) {\n            emit RecoveryInitiated(reason);\n        } catch {\n            emit RecoveryInitiated(\"NameWrapper call failed without a specified reason.\");\n        }\n\n        address resolverAddress = ens.resolver(subnode);\n        if (resolverAddress != address(0)) {\n            ResolverOriginal resolver = ResolverOriginal(resolverAddress);\n            try resolver.addr(subnode) returns (address payable resolvedAddress) {\n                if (resolvedAddress == claimant) {\n                    emit OwnershipVerified(claimant, subdomain);\n                    return true;\n                }\n            } catch {\n                emit RecoveryInitiated(\"Resolver call failed without a specified reason.\");\n            }\n        } else {\n            emit RecoveryInitiated(\"Resolver address not found for node.\");\n        }\n\n        return false;\n    }\n\n    function addAdditionalValidator(address validator) external onlyOwner {\n        additionalValidators[validator] = true;\n    }\n\n    function removeAdditionalValidator(address validator) external onlyOwner {\n        additionalValidators[validator] = false;\n    }\n\n    function addAdditionalAgent(address agent) external onlyOwner {\n        additionalAgents[agent] = true;\n    }\n\n    function removeAdditionalAgent(address agent) external onlyOwner {\n        additionalAgents[agent] = false;\n    }\n\n    function withdrawAGI(uint256 amount) external onlyOwner nonReentrant {\n        require(amount > 0 && amount <= agiToken.balanceOf(address(this)), \"Invalid amount\");\n        agiToken.transfer(msg.sender, amount);\n    }\n\n    function canAccessPremiumFeature(address user) public view returns (bool) {\n        return reputation[user] >= premiumReputationThreshold;\n    }\n\n    function contributeToRewardPool(uint256 amount) external whenNotPaused nonReentrant {\n        require(amount > 0, \"Invalid amount\");\n        agiToken.transferFrom(msg.sender, address(this), amount);\n        emit RewardPoolContribution(msg.sender, amount);\n    }\n\n    function addAGIType(address nftAddress, uint256 payoutPercentage) external onlyOwner {\n        require(nftAddress != address(0) && payoutPercentage > 0 && payoutPercentage <= 100, \"Invalid parameters\");\n\n        bool exists = false;\n        for (uint256 i = 0; i < agiTypes.length; i++) {\n            if (agiTypes[i].nftAddress == nftAddress) {\n                agiTypes[i].payoutPercentage = payoutPercentage;\n                exists = true;\n                break;\n            }\n        }\n        if (!exists) {\n            agiTypes.push(AGIType({ nftAddress: nftAddress, payoutPercentage: payoutPercentage }));\n        }\n\n        emit AGITypeUpdated(nftAddress, payoutPercentage);\n    }\n\n    function getHighestPayoutPercentage(address agent) public view returns (uint256) {\n        uint256 highestPercentage = 0;\n        for (uint256 i = 0; i < agiTypes.length; i++) {\n            if (IERC721(agiTypes[i].nftAddress).balanceOf(agent) > 0 && agiTypes[i].payoutPercentage > highestPercentage) {\n                highestPercentage = agiTypes[i].payoutPercentage;\n            }\n        }\n        return highestPercentage;\n    }\n}\n"},"contracts/test/ERC20NoReturn.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20NoReturn is ERC20 {\n    constructor() ERC20(\"No Return Token\", \"NORET\") {}\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), to, amount);\n        assembly {\n            return(0, 0)\n        }\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n        _spendAllowance(from, _msgSender(), amount);\n        _transfer(from, to, amount);\n        assembly {\n            return(0, 0)\n        }\n    }\n}\n"},"contracts/test/FailTransferToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract FailTransferToken is ERC20 {\n    constructor() ERC20(\"Fail Transfer Token\", \"FAIL\") {}\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n\n    function transfer(address, uint256) public pure override returns (bool) {\n        return false;\n    }\n}\n"},"contracts/test/FailingERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract FailingERC20 is ERC20 {\n    bool public failTransfers;\n    bool public failTransferFroms;\n\n    constructor() ERC20(\"Failing ERC20\", \"FAILX\") {}\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n\n    function setFailTransfers(bool value) external {\n        failTransfers = value;\n    }\n\n    function setFailTransferFroms(bool value) external {\n        failTransferFroms = value;\n    }\n\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        if (failTransfers) {\n            return false;\n        }\n        return super.transfer(to, amount);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n        if (failTransferFroms) {\n            return false;\n        }\n        return super.transferFrom(from, to, amount);\n    }\n}\n"},"contracts/test/MarketplaceReceiverMocks.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n\ninterface IAGIJobManagerMarketplace {\n    function purchaseNFT(uint256 tokenId) external;\n}\n\ncontract NonReceiverBuyer {\n    function approveToken(address token, address spender, uint256 amount) external {\n        IERC20(token).approve(spender, amount);\n    }\n\n    function purchase(address manager, uint256 tokenId) external {\n        IAGIJobManagerMarketplace(manager).purchaseNFT(tokenId);\n    }\n}\n\ncontract ERC721ReceiverBuyer is IERC721Receiver {\n    function approveToken(address token, address spender, uint256 amount) external {\n        IERC20(token).approve(spender, amount);\n    }\n\n    function purchase(address manager, uint256 tokenId) external {\n        IAGIJobManagerMarketplace(manager).purchaseNFT(tokenId);\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n}\n"},"contracts/test/MockENS.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract MockENS {\n    mapping(bytes32 => address) private resolvers;\n\n    function setResolver(bytes32 node, address resolverAddr) external {\n        resolvers[node] = resolverAddr;\n    }\n\n    function resolver(bytes32 node) external view returns (address) {\n        return resolvers[node];\n    }\n}\n"},"contracts/test/MockERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    constructor() ERC20(\"Mock AGI\", \"mAGI\") {}\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n}\n"},"contracts/test/MockERC721.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\n\ncontract MockERC721 is ERC721 {\n    uint256 private nextTokenId = 1;\n\n    constructor() ERC721(\"Mock AGIType\", \"MAGI\") {}\n\n    function mint(address to) external returns (uint256) {\n        uint256 tokenId = nextTokenId++;\n        _mint(to, tokenId);\n        return tokenId;\n    }\n}\n"},"contracts/test/MockNameWrapper.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract MockNameWrapper {\n    mapping(uint256 => address) private owners;\n\n    function setOwner(uint256 id, address owner) external {\n        owners[id] = owner;\n    }\n\n    function ownerOf(uint256 id) external view returns (address) {\n        return owners[id];\n    }\n}\n"},"contracts/test/MockResolver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\ncontract MockResolver {\n    mapping(bytes32 => address) private addresses;\n\n    function setAddr(bytes32 node, address resolved) external {\n        addresses[node] = resolved;\n    }\n\n    function addr(bytes32 node) external view returns (address payable) {\n        return payable(addresses[node]);\n    }\n}\n"},"contracts/test/ReentrantERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IAGIJobManager {\n    function purchaseNFT(uint256 tokenId) external;\n}\n\ncontract ReentrantERC20 is ERC20 {\n    address public manager;\n    uint256 public reenterTokenId;\n    bool public reenterEnabled;\n    bool public reenterAttempted;\n\n    constructor() ERC20(\"Reentrant AGI\", \"rAGI\") {}\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n\n    function setReentry(address _manager, uint256 _tokenId, bool _enabled) external {\n        manager = _manager;\n        reenterTokenId = _tokenId;\n        reenterEnabled = _enabled;\n        reenterAttempted = false;\n    }\n\n    function approveManager(uint256 amount) external {\n        require(manager != address(0), \"manager not set\");\n        _approve(address(this), manager, amount);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n        if (reenterEnabled && !reenterAttempted && manager != address(0)) {\n            reenterAttempted = true;\n            IAGIJobManager(manager).purchaseNFT(reenterTokenId);\n        }\n        return super.transferFrom(from, to, amount);\n    }\n}\n"},"contracts/test/TestableAGIJobManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"../AGIJobManager.sol\";\n\ncontract TestableAGIJobManager is AGIJobManager {\n    constructor(\n        address _agiTokenAddress,\n        string memory _baseIpfsUrl,\n        address _ensAddress,\n        address _nameWrapperAddress,\n        bytes32 _clubRootNode,\n        bytes32 _agentRootNode,\n        bytes32 _clubRootNodeAlpha,\n        bytes32 _agentRootNodeAlpha,\n        bytes32 _validatorMerkleRoot,\n        bytes32 _agentMerkleRoot\n    )\n        AGIJobManager(\n            _agiTokenAddress,\n            _baseIpfsUrl,\n            _ensAddress,\n            _nameWrapperAddress,\n            _clubRootNode,\n            _agentRootNode,\n            _clubRootNodeAlpha,\n            _agentRootNodeAlpha,\n            _validatorMerkleRoot,\n            _agentMerkleRoot\n        )\n    {}\n\n    function setValidationRewardPercentageUnsafe(uint256 _percentage) external {\n        validationRewardPercentage = _percentage;\n    }\n\n    function setJobMetadata(\n        uint256 jobId,\n        string calldata completionURI,\n        string calldata ipfsHash,\n        bool completionRequested,\n        bool mintNft\n    ) external {\n        Job storage job = jobs[jobId];\n        job.jobCompletionURI = completionURI;\n        job.ipfsHash = ipfsHash;\n        job.completionRequested = completionRequested;\n        if (mintNft) {\n            _mintJobNft(job);\n        }\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"runs":500},"evmVersion":"london","viaIR":false,"metadata":{"bytecodeHash":"none"},"debug":{"revertStrings":"strip"},"outputSelection":{"*":{"*":["abi","evm.bytecode"]}}}}