# Bytecode size + job getter notes

## Why `jobs` is internal

`jobs` is intentionally marked `internal` to avoid the legacy Solidity autogenerated getter for a very large struct. That getter hit stack‑too‑deep without `viaIR`, so we replace it with small, targeted view functions and keep `viaIR` disabled by default.

## Use these getters instead

Use the small read helpers instead of `jobs(jobId)`:

- `getJobCore(jobId)` → employer, assignedAgent, payout, duration, assignedAt, completed, disputed, expired, agentPayoutPct
- `getJobValidation(jobId)` → completionRequested, validatorApprovals, validatorDisapprovals, completionRequestedAt, disputedAt
- `getJobURIs(jobId)` for URIs and status metadata

Each function reuses `_job(jobId)` to revert cleanly on `JobNotFound`. Validator sets are tracked via events (`JobValidated`/`JobDisapproved`) for off-chain indexing.

## Runtime bytecode size guardrail

Ethereum mainnet enforces a 24,576‑byte runtime bytecode cap (EIP‑170). We keep a safety margin and require **≤ 24,575 bytes** for `AGIJobManager`.

After compiling, check the runtime bytecode size:

```bash
node scripts/check-bytecode-size.js
```

This uses the compiled Truffle artifacts (`build/contracts/AGIJobManager.json`) and fails if the deployed bytecode exceeds the limit.

## Compiler settings

`viaIR` stays **disabled** by default. Keep `SOLC_VERSION`, optimizer runs, and `metadata.bytecodeHash` consistent for reproducible verification.
